Дан массив различных целых чисел. Мы хотим отсортировать его следующим образом: a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N, 0 <= k <= N.
При этом единственная допустимая операция: поменять местами два соседних элемента.

Необходимо написать функцию вида int n_swaps(int *a, size_t size), возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.
Обращаю внимание, что индекс k может быть с краю (то есть, отсортированный список уже обладает нужным порядком элементов), а также что k
не является параметром функции, а должен получаться в результате работы алгоритма.

Решение:
    1. Найти минимум
    2. Сдвинуть минимум в самую леую позицию, считать операции
    3. В цикле сдвигать минимум вправо, считать операции
    4. Выдать положение минимального элемента при которм число перестановок соседних элементов минимально.

Запуск тестов:
    Task2 <путь к файлу с тестовыми данными>

Описание полей TestSet.json:

    "name" - описание теста, текстовая строка
    "data" - массив целых чисел, сортируемые данные

