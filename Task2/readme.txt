Дан массив различных целых чисел. Мы хотим отсортировать его следующим образом: a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N, 0 <= k <= N.
При этом единственная допустимая операция: поменять местами два соседних элемента.

Необходимо написать функцию вида int n_swaps(int *a, size_t size), возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.
Обращаю внимание, что индекс k может быть с краю (то есть, отсортированный список уже обладает нужным порядком элементов), а также что k
не является параметром функции, а должен получаться в результате работы алгоритма.

Решение:
    1. Найти минимальный элемент в массиве.
    2. Сдвинуть этот элемент в самую леую позицию, посчитать число операции.
    3. В цикле сдвигать этот элемент вправо, считать операции: 1 + число операций на упорядочивание левой части + число операций на упорядочивание правой части массива.
    4. Выдать индекс минимального элемента при которм число операций элементов минимально.

Запуск тестов:
    Task2 <путь к файлу с тестовыми данными>

Описание полей TestSet.json:

    "name" - описание теста, текстовая строка
    "data" - массив целых чисел, сортируемые данные

