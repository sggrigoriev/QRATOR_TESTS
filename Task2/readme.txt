Дан массив различных целых чисел. Мы хотим отсортировать его следующим образом: a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N, 0 <= k <= N.
При этом единственная допустимая операция: поменять местами два соседних элемента.

Необходимо написать функцию вида int n_swaps(int *a, size_t size), возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.
Обращаю внимание, что индекс k может быть с краю (то есть, отсортированный список уже обладает нужным порядком элементов), а также что k
не является параметром функции, а должен получаться в результате работы алгоритма.

Решение:
    1. Расчитать число операций по нахождению минимума в массиве.
    Если существуют a_i, ... a_j, равные min, то за k принимаем минимальный из таких индексов. Немного тем самым
    сэкономим на числе операций в поиске индекса минимального элемента в массиве.
    2. Расчитать число операция для сортировки по убыванию массива a_0,...,a_k-1.
    3. Расчитать число операций для сортировки по возрастанию массива a_k+1, ... a_N.
    4. Просумировать полученное число операций на шагах 1,2,3
Если входные данные некорректны:
    a == NULL, N < 3
    вернуть -1

    Используется немного улучшенная гномья сротировка.
    Улучшение:
        Запоминается индекс элемента, стоящего не на своём месте. После того, как элемент оказывается на своём месте, алгоритм
        продолжает попарное сравнение с сохранённого индекса.
    Причина: гномья на тестовых данных вела себя немного лучше, чем шейкерная.
    Ассимптотическая сложность у них одинаковая O(N^2)
        Сортировка пузырьком априори хуже на любых наборах, кроме самого плохого (обратная упорядоченность).
        Других сортировок с перестановкой соседних элементов я не знаю.

    При расчёте учитываются операции чтения из массива и записи в массив.

Результаты на тестовых данных:

    Гномья сортировка:
        Array=1 2 					    Array=1 2 Operations = -1
        Array=1 2 3 4 5 				Array=1 2 3 4 5 Operations = 8
        Array=5 4 3 2 1 				Array=5 4 3 2 1 Operations = 12
        Array=1 1 1 					Array=1 1 1 Operations = 4
        Array=1 2 3 4 5 1 4 3 2 1 		Array=1 1 1 2 2 3 3 4 4 5 Operations = 98       лучше
        Array=5 7 6 8 0 2 3 4 18 10 	Array=8 7 6 5 0 2 3 4 10 18 Operations = 42     лучше
        Array=2 3 4 5 0 5 4 3 2 1 		Array=5 4 3 2 0 1 2 3 4 5 Operations = 82       хуже

    Шейкерная сортировка:
        Array=1 2 					    Array=1 2 Operations = -1
        Array=1 2 3 4 5 				Array=1 2 3 4 5 Operations = 8
        Array=5 4 3 2 1 				Array=5 4 3 2 1 Operations = 12
        Array=1 1 1 					Array=1 1 1 Operations = 4
        Array=1 2 3 4 5 1 4 3 2 1 		Array=1 1 1 2 2 3 3 4 4 5 Operations = 105      хуже
        Array=5 7 6 8 0 2 3 4 18 10 	Array=8 7 6 5 0 2 3 4 10 18 Operations = 44     хуже
        Array=2 3 4 5 0 5 4 3 2 1 		Array=5 4 3 2 0 1 2 3 4 5 Operations = 75       лучше