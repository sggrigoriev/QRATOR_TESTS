Дан массив различных целых чисел. Мы хотим отсортировать его следующим образом: a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N, 0 <= k <= N.
При этом единственная допустимая операция: поменять местами два соседних элемента.

Необходимо написать функцию вида int n_swaps(int *a, size_t size), возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.
Обращаю внимание, что индекс k может быть с краю (то есть, отсортированный список уже обладает нужным порядком элементов), а также что k
не является параметром функции, а должен получаться в результате работы алгоритма.

Решение:
    1. Найти минимальный элемент в массиве.
    2. Переставить его с ближней от него границе. Если расстояние до границ одинаковое, то направо. Посчитать число парных перестановок.
    3. Уменьшить размер массива на 1. Если был сдвиг влево, то уменьшить адрес начала массива на 1.
    4. Выполнять 1-3, пока не кончатся элементы в массиве.
    5. Выдать индекс минимального элемента при которм число операций элементов минимально.

Запуск тестов:
    Task2 <путь к файлу с тестовыми данными>

Описание полей TestSet.json:

    "name" - описание теста, текстовая строка
    "data" - массив целых чисел, сортируемые данные

